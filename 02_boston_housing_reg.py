# -*- coding: utf-8 -*-
"""02.Boston_housing_reg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q4LoECyySbv3L0pF_6PX62dPTwkVbuaC
"""

import tensorflow as tf
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.boston_housing.load_data(
    path='boston_housing.npz', test_split=0.2, seed=113
)
# x,y 설정했네 ㅇㅇ; 그리고 print로 찍었다 ㅇㅇ
# -> split 까지 했네

# 이거를 근데 data 자체로 저장해서 보는게 좋지 않나?...?
print(x_train.shape)
print(y_train.shape)
print(x_test.shape)
print(x_test.shape)

for ix,d in enumerate(x_train[0]):
  print(ix+1, type(d))
# 라벨링을 직접해야하네..

data_label = ["범죄율","토지비율(주거)","비소매업면적비율","강인접보너스+1","산화질소농도","방 수","건축년도1940 이전","고용센터인접성","고속도로인접성","1만달러당재산세","교사-학생비","흑인비율","하위계층비율"]
# enumerate -> idx , data 둘 다
for ix,d in enumerate(x_train[0]):
  print(f". {data_label[ix]} : {d}",end=" ")

print()

print("y: ",y_train[0]*1000*14000)

#2. 데이터의 유형이나 관련 필드 등을 분석 분류
#      CRIM: 도시별 1인당 범죄율   25,000제곱피트(sq.ft) 이상
#      부지로 지정된 주거용 토지의 비율 ZN
#      INDUS: 도시별 비소매업용 면적 비율
#      CHAS: 찰스 강 더미 변수 (= 해당 구역이 강 경계를 포함하는 경우 1, 그렇지 않은 경우 0)
#      NOX: 산화질소 농도 (1,000만 분의 1)
#      RM: 가구당 평균 방 개수
#      AGE: 1940년 이전에 지어진 자가 주택의 비율
#      DIS: 보스턴 5개 고용 센터까지의 가중 거리
#      RAD: 방사형 고속도로 접근성 지수
#      TAX: 1만 달러당 재산세 전액 세율
#      PTRATIO: 도시별 교사-학생 비율
#      B 1000(Bk - 0.63)^2 (Bk는 도시별 흑인 비율)
#      LSTAT: 인구 하위 계층 비율 (%)
#      y = MEDV: 자가 주택의 중간 가치 (1,000달러대)

# -> 컬럼을 어떻게 출력시키지?
#  .'. x = data[:12] , y=data[-1] 이렇게 되려나?

import pandas as pd

data = tf.keras.datasets.boston_housing.load_data(
    path='boston_housing.npz')
X = data[:][0]
print(X)
# 기본적으로 튜플 데이터 컬럼 설명을 해야 아니 컬럼이 없는데? 컬럼을 어떻게봐야하지?

!apt-get install -y fonts-nanum

import matplotlib.font_manager as fm
import matplotlib as mpl

# 폰트 설정
plt.rc('font', family='NanumGothic')

# 마이너스 부호 깨짐 방지
mpl.rcParams['axes.unicode_minus'] = False

# Rebuild the font cache
fm.cachedir.cleanup()
fm._reload_cachedir()

import matplotlib.pyplot as plt
# x_train[:,0] - 범죄율만 인덱스 함 x_train 이 2차원 데이터로 존재함


for ix in range(len(x_train[0])):
  plt.subplot(4,4,ix+1)
  plt.scatter(y_train, x_train[:,ix], label = data_label[ix], s=1)
  plt.title(data_label[ix])
plt.show()

for ix in range(len(x_train[0])):
  print(x_train[:,ix].max())
  print(x_train[:,ix].min())
  print(x_train[:,ix].mean())
  print(x_train[:,ix].std())
  print()
# 0번째 데이터의 값들 출력

print(x_train[0])
# print(type(x_train[0]))

# 3,4번 필드 제외한 데이터를 정규화하기
except_datas = [3,4]

norm_mean=[]
norm_std=[]

for ix in range(len(x_train[0])):
  if ix in except_datas:
    norm_mean.append(0)
    norm_std.append(0)
    continue
  norm_mean.append(x_train[:,ix].mean())
  norm_std.append(x_train[:,ix].std())

def normal_data(target_data):
  for ix in range(len(target_data[0])):
    if ix in except_datas:
      continue
    # 데이터를 표준 정규분포로 스케일링 n - 평균 / std
    target_data[:,ix] = (target_data[:,ix]-norm_mean[ix])/norm_std[ix]
  return target_data



x_train = normal_data(x_train)
x_test = normal_data(x_test)
print(x_train[:3])
print(x_test[:3])
print(x_train[:,0].std())
print(x_train[:,0].mean())
print(x_train[:,-1].std())
print(x_train[:,-1].mean())

# 나는 정규화도 쳐박았는데?.?

# import numpy as np

# # 정규화에서 제외할 컬럼 인덱스
# except_datas = [3, 4]

# def normal_data_L1(target_data):
#     target_data = target_data.copy().astype(float)  # 원본 보호 + float 변환

#     # 각 행(row)별로 합계 계산 (L1 정규화)
#     for i in range(len(target_data)):
#         # 제외된 컬럼은 정규화 계산에서 빼고 합산
#         valid_idx = [j for j in range(target_data.shape[1]) if j not in except_datas]  #3,4 제외
#         row_sum = np.sum(np.abs(target_data[i, valid_idx]))  # L1 노름 (절댓값 합)

#         if row_sum == 0:
#             continue  # 0으로 나눠지는 경우 방지

#         # 각 valid 컬럼을 L1 정규화
#         for j in valid_idx:
#             target_data[i, j] = target_data[i, j] / row_sum

#     return target_data

# # 적용
# x_train = normal_data_L1(x_train)
# x_test = normal_data_L1(x_test)

# # 결과 확인
# print(x_train[:3])
# print()
# print(x_test[:3])

from tensorflow.keras import Input,Sequential
from tensorflow.keras.layers import Dense , Dropout
import numpy as np
import pandas as pd

import random
random.seed(123)
np.random.seed(123)
tf.random.set_seed(123)

model = Sequential()

model.add(Input((13,)))

model.add(Dense(256 , activation="relu"))
# model.add(Dropout(0.4))
model.add(Dense(64,activation="relu"))
# model.add(Dropout(0.3))
model.add(Dense(16,activation="relu"))
model.add(Dense(1))

model.compile(loss ="mse" , optimizer= "SGD", metrics= ["MAE"] )

# 훈련시작

print(y_train.shape)
print(y_train[0])
y_mean=y_train.mean()
y_std = y_train.std()
y_train = (y_train-y_mean)/y_std
print(y_train[0])
print(y_test.shape)
print(y_test[10])
y_test = (y_test-y_mean)/y_std
print(y_test[10])
fhist = model.fit(x_train,y_train,validation_data=(x_test,y_test),epochs=500)

# 표준화 후 L1 정규화 진행

plt.plot(fhist.history["loss"],label="mse")
plt.plot(fhist.history["MAE"],label="mae")
plt.legend()
plt.show()

plt.plot(model_hist.history['loss'] , label = "mse")
plt.plot(model_hist.history['MAE'] , label = "mae")
plt.show()

y_pred = model.predict(x_test)
# pred => test
plt.plot(y_test , y_test , label="y_True")
plt.scatter(y_pred , y_pred , label="y_Pred",c="Orange" )

plt.legend()
plt.show()

y_test.shape
y_pred.shape

y_pred = y_pred.reshape(len(y_pred))
# or
#y_pred = y_pred.reshape(-1)

print ((1 - y_pred[0] / y_test[0])*100 )



# t = (y - mean) /std >  y=t*std+mean
#y_mean
#y_std
y_pred = y_pred*y_std+y_mean
y_test = y_test*y_std+y_mean
print(y_pred[1])
print(y_test[1])
print((1-(y_pred[1]/y_test[1]))*100)
rate = 1-y_pred/y_test
print(rate[:5])
rate = np.absolute(rate)
err_rate_mean = rate[:5].mean()
print(f"현재 모델의 전체 오차 평균 백분율은 {err_rate_mean:.2%}")







"""# 데이터 정의
####     CRIM: 도시별 1인당 범죄율   25,000제곱피트(sq.ft) 이상
#####      부지로 지정된 주거용 토지의 비율 ZN
#####      INDUS: 도시별 비소매업용 면적 비율
#####      CHAS: 찰스 강 더미 변수 (= 해당 구역이 강 경계를 포함하는 경우 1, 그렇지 않은 경우 0)
#####      NOX: 산화질소 농도 (1,000만 분의 1)
#####      RM: 가구당 평균 방 개수
#####      AGE: 1940년 이전에 지어진 자가 주택의 비율
#####      DIS: 보스턴 5개 고용 센터까지의 가중 거리
#####      RAD: 방사형 고속도로 접근성 지수
#####      TAX: 1만 달러당 재산세 전액 세율
#####      PTRATIO: 도시별 교사-학생 비율
#####      B 1000(Bk - 0.63)^2 (Bk는 도시별 흑인 비율)
#####      LSTAT: 인구 하위 계층 비율 (%)
#####      y = MEDV: 자가 주택의 중간 가치 (1,000달러대)

# 개발도구
colab opendata , kears , tensorflow, numpy, matplotlib
# 순서
1. 데이터 수집 2. 데이터 분석(columns) 3. 전처리 4. 순차모델 구성 5. 훈련모델시각화 6, 정확도 시각화 7, 정확도 수치화
"""